# -*- coding: utf-8 -*-
"""mfcc.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17vAFvPxgWzZrrMzyrcUFBoF2BWd8BfYC
"""

import librosa, librosa.display
from librosa.feature import mfcc
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import os
import glob
from sklearn.metrics.pairwise import cosine_similarity
from scipy.spatial.distance import cdist
from scipy.spatial.distance import euclidean
from fastdtw import fastdtw

pip install fastdtw

from google.colab import drive
drive.mount('/content/drive')

cd ..

# Set the path to the parent directory containing the subfolders
parent_dir = "/content/drive/MyDrive/music/covers"

# Create an empty list to store the lengths of all MFCC feature sets
lengths = []

# Iterate through each subfolder
for subdir in os.listdir(parent_dir):
      print(subdir)  # add this line to check the list of subdirectories
      # Set the path to the current subfolder
      subdir_path = os.path.join(parent_dir, subdir)


      # Check if the current item is a directory
      if os.path.isdir(subdir_path):
          # Use glob to find all files in the current subfolder
          files = glob.glob(os.path.join(subdir_path, "*"))
          #print(files)

          # Iterate through each file in the current subfolder
          for i, file1 in enumerate(files):
              for j, file2 in enumerate(files):
                  if i < j:
                      # Load the audio data from the two files
                      data1, sr = librosa.load(file1, sr=44100)
                      data2, sr = librosa.load(file2, sr=44100)

                      # Extract the MFCC features for the two audio signals with the same sampling rate
                      mfcc1 = librosa.feature.mfcc(y=data1, sr=sr, n_mfcc=13)
                      mfcc2 = librosa.feature.mfcc(y=data2, sr=sr, n_mfcc=13)

                      # Calculate the minimum length of the two MFCC feature sets
                      min_len = min(mfcc1.shape[1], mfcc2.shape[1])
                      lengths.append(min_len)
# Calculate the median length of all MFCC feature sets
median_length = int(np.median(lengths))
print(f"The median length of all MFCC feature sets is: {median_length}")
# Create an empty list to store cross-similarity matrices
cross_similarities = []
# Initialize a counter variable
counter = 0

# Iterate through each subfolder again
for subdir in os.listdir(parent_dir):
      # Set the path to the current subfolder
      subdir_path = os.path.join(parent_dir, subdir)

      # Check if the current item is a directory
      if os.path.isdir(subdir_path):
          # Use glob to find all files in the current subfolder
          files = glob.glob(os.path.join(subdir_path, "*"))

           # Create a folder to store the cross-similarity matrices
          matrix_folder = os.path.join(parent_dir, "cross_similarity_matrices")
          os.makedirs(matrix_folder, exist_ok=True)


          # Iterate through each file in the current subfolder
          for i, file1 in enumerate(files):
              for j, file2 in enumerate(files):
                  if i < j:
                      # Load the audio data from the two files
                      data1, sr = librosa.load(file1, sr=44100)
                      data2, sr = librosa.load(file2, sr=44100)
                      data1 = librosa.to_mono(data1)
                      data2 = librosa.to_mono(data2)

                      # Extract the MFCC features for the two audio signals with the same sampling rate
                      mfcc1 = librosa.feature.mfcc(y=data1, sr=sr, n_mfcc=13)
                      mfcc2 = librosa.feature.mfcc(y=data2, sr=sr, n_mfcc=13)

                      # Slice or zero-pad the MFCC feature sets to the median length
                      if mfcc1.shape[1] >= median_length:
                          mfcc1b = mfcc1[:, :median_length]
                      else:
                          mfcc1b = np.pad(mfcc1, ((0, 0), (0, median_length - mfcc1.shape[1])), mode='constant')

                      if mfcc2.shape[1] >= median_length:
                          mfcc2b = mfcc2[:, :median_length]
                      else:
                          mfcc2b = np.pad(mfcc2, ((0, 0), (0, median_length - mfcc2.shape[1])), mode='constant')
                      print(mfcc1b.shape)
                      print(mfcc2b.shape)

                      # Apply DTW to find the optimal warping path
                      distance, path = fastdtw(mfcc1b, mfcc2b)
                      path = np.array(path)
                      aligned_mfcc1 = mfcc1b[path[:, 0]]
                      aligned_mfcc2 = mfcc2b[path[:, 1]]
                      cross_similarity = cdist(aligned_mfcc1.T, aligned_mfcc2.T, metric='euclidean')
                      # Save the cross-similarity matrix to a file

                      matrix_filename = f"cross_similarity_{counter}.npy"
                      matrix_filepath = os.path.join(matrix_folder, matrix_filename)
                      np.save(matrix_filepath, cross_similarity)
                      counter+=1

                      print(f"Cross-similarity matrix between {file1} and {file2} saved: {matrix_filepath} (shape: {cross_similarity.shape})")
                      #print(f"Saved cross-similarity matrix: {matrix_filepath} (shape: {cross_similarity.shape})")
          # Convert the list of cross-similarity matrices to a numpy array
          #cross_similarities_array = np.array(cross_similarities)
#cross_similarities_array = np.array(cross_similarities)

# Set the path to the parent directory containing the subfolders
parent_dir = "/content/drive/MyDrive/music/similarities/cross_similarity_matrices"

# Iterate through each file in the parent directory
for file_name in os.listdir(parent_dir):
    # Set the path to the current file
    file_path = os.path.join(parent_dir, file_name)

    # Check if the current item is a file
    if os.path.isfile(file_path) and file_name.endswith(".npy"):
        # Load the cross-similarity matrix
        cross_similarity = np.load(file_path)

        # Visualize the matrix
        plt.imshow(cross_similarity, cmap='hot', origin='lower')
        plt.colorbar()
        plt.title(f"Cross Similarity Matrix: {file_name}")
        plt.show()