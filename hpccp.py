# -*- coding: utf-8 -*-
"""hpccp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EgNxqmSO2i-GON5mJ1M2xKkRkMui4NYP
"""

!pip install dtw
!pip install fastdtw
!pip install chroma_features

import librosa, librosa.display
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import os
import glob
from sklearn.metrics.pairwise import cosine_similarity
from scipy.spatial.distance import cdist
from scipy.spatial.distance import euclidean
from fastdtw import fastdtw
from sklearn.cluster import KMeans

from google.colab import drive
drive.mount('/content/drive')

!pip install --upgrade numba

# Set the path to the parent directory containing the subfolders
parent_dir = "/content/drive/MyDrive/music/covers"

# Create an empty list to store cross-similarity matrices
cross_similarities = []
# Initialize a counter variable
counter = 0

desired_num_frames = 1000

num_recurring_segments = 5  # Adjust this number as needed

# Function to identify recurring segments using k-means clustering
def identify_recurring_segments(self_similarity_matrix, num_segments):
    # Apply k-means clustering
    kmeans = KMeans(n_clusters=num_segments)
    clustering = kmeans.fit_predict(self_similarity_matrix)

    # Count the number of segments in each cluster
    segment_counts = np.bincount(clustering)

    # Find the indices of the segments that appear most often
    most_often_indices = np.argsort(segment_counts)[::-1][:num_segments]

    return most_often_indices

# Function to calculate the cross similarities between binary matrices
def calculate_cross_similarities(binary_matrices):
    num_matrices = len(binary_matrices)
    cross_similarities = np.zeros((num_matrices, num_matrices))

    for i in range(num_matrices):
        for j in range(i + 1, num_matrices):
            # Calculate the Jaccard similarity between the binary matrices
            intersection = np.logical_and(binary_matrices[i], binary_matrices[j])
            union = np.logical_or(binary_matrices[i], binary_matrices[j])
            similarity = np.sum(intersection) / np.sum(union)

            # Assign the similarity to the cross similarity matrix
            cross_similarities[i, j] = similarity
            cross_similarities[j, i] = similarity

    return cross_similarities


# Create a folder to store the binary matrices
matrix_folder = os.path.join('/content/drive/MyDrive/music', "binary_matrices")
os.makedirs(matrix_folder, exist_ok=True)

# Iterate through each subfolder
for subdir in os.listdir(parent_dir):
      # Set the path to the current subfolder
      subdir_path = os.path.join(parent_dir, subdir)

      # Check if the current item is a directory
      if os.path.isdir(subdir_path):
          # Use glob to find all files in the current subfolder
          files = glob.glob(os.path.join(subdir_path, "*"))

           # Create a folder to store the cross-similarity matrices
          #matrix_folder = os.path.join(parent_dir, "binary_matrices")
          #os.makedirs(matrix_folder, exist_ok=True)


          # Iterate through each file in the current subfolder
          for i, file1 in enumerate(files):
              for j, file2 in enumerate(files):
                  if i < j:
                      # Load the audio data from the two files
                      data1, sr = librosa.load(file1, sr=22050)
                      data2, sr = librosa.load(file2, sr=22050)
                      data1 = librosa.to_mono(data1)
                      data2 = librosa.to_mono(data2)

                      # Compute chromagram
                      chromagram1 = librosa.feature.chroma_cqt(y=data1, sr=sr)
                      chromagram2 = librosa.feature.chroma_cqt(y=data2, sr=sr)
                      # Adjust the number of frames to the desired number
                      #hpcp1 = chromagram1[:, ::chromagram1.shape[1] // desired_num_frames]
                      #hpcp2 = chromagram2[:, ::chromagram2.shape[1] // desired_num_frames]

                      # Adjust the number of frames to the desired number
                      if chromagram1.shape[1] > 0:
                          hpcp1 = chromagram1[:, ::chromagram1.shape[1] // desired_num_frames]
                      else:
                          # Handle the case when the number of frames is zero
                          hpcp1 = chromagram1.copy()

                      if chromagram2.shape[1] > 0:
                          hpcp2 = chromagram2[:, ::chromagram2.shape[1] // desired_num_frames]
                      else:
                          # Handle the case when the number of frames is zero
                          hpcp2 = chromagram2.copy()

                      # Compute HPCP features
                      hpcp1 = librosa.feature.chroma_cens(C=hpcp1, norm=None)
                      hpcp2 = librosa.feature.chroma_cens(C=hpcp2, norm=None)

                      #print(hpcp1.shape)
                      #print(hpcp2.shape)
                      min_len = min(hpcp1.shape[1], hpcp2.shape[1])
                      hpcp1 = hpcp1[:, :min_len]
                      hpcp2 = hpcp2[:, :min_len]


                      # Apply DTW to find the optimal warping path
                      distance, path = fastdtw(hpcp1, hpcp2)
                      path = np.array(path)
                      aligned_hpcp1 = hpcp1[path[:, 0]]
                      aligned_hpcp2 = hpcp2[path[:, 1]]
                      self_similarity1 = cdist(aligned_hpcp1.T, aligned_hpcp1.T, metric='euclidean')
                      self_similarity2 = cdist(aligned_hpcp2.T, aligned_hpcp2.T, metric='euclidean')

                      # Resample the aligned_hpcp1 and aligned_hpcp2 back to the original length
                      aligned_data1 = librosa.resample(aligned_hpcp1.T, orig_sr=sr, target_sr=sr)
                      aligned_data2 = librosa.resample(aligned_hpcp2.T, orig_sr=sr, target_sr=sr)

                      # Play the aligned audio
                      librosa.display.waveshow(aligned_data1, sr=sr)
                      librosa.display.waveshow(aligned_data2, sr=sr)


                      # Apply k-means clustering to identify recurring segments
                      recurring_segments1 = identify_recurring_segments(self_similarity1, num_recurring_segments)
                      recurring_segments2 = identify_recurring_segments(self_similarity2, num_recurring_segments)
                      # Set the similarity threshold
                      similarity_threshold = 0.3

                      # Create the binary matrix based on the recurring segments
                      binary_matrix = np.zeros((num_recurring_segments, num_recurring_segments))
                      for seg1 in recurring_segments1:
                        for seg2 in recurring_segments2:
                          if self_similarity1[seg1, seg2] > similarity_threshold and self_similarity2[seg1, seg2] > similarity_threshold:
                              binary_matrix[seg1, seg2] = 1



                      # Save the binary matrix to a file
                      matrix_filename = f"binary_matrix_{counter}.npy"
                      matrix_filepath = os.path.join(matrix_folder, matrix_filename)
                      np.save(matrix_filepath, binary_matrix)
                      counter += 1

                      # Add the binary matrix to the list
                      cross_similarities.append(binary_matrix)

                      #cross_similarity = cdist(self_similarity1, self_similarity2, metric='euclidean')
                      # Save the cross-similarity matrix to a file

                      #matrix_filename = f"cross_similarity_{counter}.npy"
                      #matrix_filepath = os.path.join(matrix_folder, matrix_filename)
                      #np.save(matrix_filepath, cross_similarity)
                      #counter+=1

                  # Print the shape of the cross-similarity matrix
                      #print(f"Cross-similarity matrix between {file1} and {file2} saved: {matrix_filepath} (shape: {cross_similarity.shape})")
          # Convert the list of cross-similarity matrices to a numpy array
          # Convert the list of binary matrices to a numpy array
binary_matrices_array = np.array(cross_similarities)

        # Calculate the cross similarities between the binary matrices
cross_similarities_array = calculate_cross_similarities(binary_matrices_array)
        # Save the cross-similarity matrix to a file
cross_similarities_filepath = os.path.join(matrix_folder, "cross_similarities.npy")
np.save(cross_similarities_filepath, cross_similarities_array)

print(f"Cross-similarity matrix saved: {cross_similarities_filepath} (shape: {cross_similarities_array.shape})")

# Set the path to the parent directory containing the subfolders
parent_dir = "/content/drive/MyDrive/music/binary_matrices"

# Iterate through each file in the parent directory
for file_name in os.listdir(parent_dir):
    # Set the path to the current file
    file_path = os.path.join(parent_dir, file_name)

    # Check if the current item is a file
    if os.path.isfile(file_path) and file_name.endswith(".npy"):
        # Load the cross-similarity matrix
        cross_similarity = np.load(file_path)

        # Visualize the matrix
        plt.imshow(cross_similarity, cmap='hot', origin='lower')
        plt.colorbar()
        plt.title(f"Binary Similarity Matrix: {file_name}")
        plt.show()

file1 = '/content/drive/MyDrive/music/covers/c3/George Dalaras - Historia de un amor.mp3'
file2 = '/content/drive/MyDrive/music/covers/c3/Historia De Un Amor.mp3'
file3 = '/content/drive/MyDrive/music/covers/c18/Beggin.mp3'
data1, sr = librosa.load(file1, sr=44100)
data2, sr = librosa.load(file2, sr=44100)
data3, sr = librosa.load(file3, sr=44100)
data1 = librosa.to_mono(data1)
data2 = librosa.to_mono(data2)
data3 = librosa.to_mono(data3)

mfcc1 = librosa.feature.mfcc(y=data1, sr=sr, n_mfcc=13)
mfcc2 = librosa.feature.mfcc(y=data2, sr=sr, n_mfcc=13)
mfcc3 = librosa.feature.mfcc(y=data3, sr=sr, n_mfcc=13)
# Compute chromagram
#chromagram1 = librosa.feature.chroma_cqt(y=data1, sr=sr)
#chromagram2 = librosa.feature.chroma_cqt(y=data2, sr=sr)
#chromagram3 = librosa.feature.chroma_cqt(y=data3, sr=sr)

                      # Compute HPCP features
#hpcp1 = librosa.feature.chroma_cens(C=chromagram1, norm=None)
#hpcp2 = librosa.feature.chroma_cens(C=chromagram2, norm=None)
#hpcp3 = librosa.feature.chroma_cens(C=chromagram3, norm=None)

min_len = min(mfcc1.shape[1], mfcc2.shape[1], mfcc3.shape[1])
#hpcp1 = hpcp1[:, :min_len]
#hpcp2 = hpcp2[:, :min_len]
#hpcp3 = hpcp3[:, :min_len]
mfcc1 = mfcc1[:, :min_len]
mfcc2 = mfcc2[:, :min_len]
mfcc3 = mfcc3[:, :min_len]

#cross_similarity = cdist(hpcp1.T, hpcp2.T, metric='euclidean')
#bad_similarity = cdist(hpcp1.T, hpcp3.T, metric='euclidean')

distance, path = fastdtw(mfcc1, mfcc2)
path = np.array(path)
aligned_mfcc1 = mfcc1[path[:, 0]]
aligned_mfcc2 = mfcc2[path[:, 1]]

mfcc_cross_similarity = cdist(aligned_mfcc1.T, aligned_mfcc2.T, metric='euclidean')
mfcc_bad_similarity = cdist(mfcc1.T, mfcc3.T, metric='euclidean')


# Visualize the matrix
# plt.imshow(cross_similarity, cmap='hot', origin='lower')
# plt.colorbar()
# plt.title(f"Cross Similarity Matrix")
# plt.show()

# plt.imshow(bad_similarity, cmap='hot', origin='lower')
# plt.colorbar()
# plt.title(f"Bad Similarity Matrix")
# plt.show()

plt.imshow(mfcc_cross_similarity, cmap='hot', origin='lower')
plt.colorbar()
plt.title(f"Cross Similarity Matrix")
plt.show()

plt.imshow(mfcc_bad_similarity, cmap='hot', origin='lower')
plt.colorbar()
plt.title(f"Bad Similarity Matrix")
plt.show()

print(distance)

file = '/content/drive/MyDrive/music/covers/c16/Da Ya Think Im Sexy.mp3'
data, sr = librosa.load(file, sr=44100)
mfcc = librosa.feature.mfcc(y=data, sr=sr, n_mfcc=13)
distance, path = fastdtw(mfcc, mfcc)
#chromagram = librosa.feature.chroma_cqt(y=data, sr=sr)
#hpcp = librosa.feature.chroma_cens(C=chromagram, norm=None)
similarity_matrix = cdist(mfcc.T, mfcc.T, metric='euclidean')
#hpcp_matrix = cdist(hpcp.T, hpcp.T, metric='cosine')
plt.imshow(similarity_matrix, cmap='hot', origin='lower')
plt.colorbar()
plt.title(f"Self Similarity Matrix")
plt.show()
# plt.imshow(hpcp_matrix, cmap='hot', origin='lower')
# plt.colorbar()
# plt.title(f"Hpcp Similarity Matrix")
# plt.show()

